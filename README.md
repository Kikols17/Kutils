# Kutils - C utils lib

This library intends to recreate the stdc++ library, but in C.


The end goal of this library is to achieve peak performance, sacrificing usability, memory safety and sanity in service of achieving speed.


## **Priorities**
This project intends to create C code with these following and SORTED priorities:
1. ***Speed*** - Modern coding culture treats speed as a "hardware problem". It's not.
2. ***Memory usage*** - In modern machines memory is not as valuable as compute, so it's not too important. However, if it can be optimized without impacting speed, it should be. Minimal memory usage is usually a sign of fast code.
3. ***Memory Safety*** - Memory safety should be taken care of by the programmer. The data structures and functions do not perform checks like null pointer dereferences. We trust the programmer to do those if and only when they are necessary, to speed up the code. If one can't be trusted with that, use Javascript or Scratch.
4. ***Usability*** - A good programmer bends themselves to the machine, not the other way around.
We try to make `Kutils` be as familiar to `stdc++` as possible, but if usability, or any other coding practices, get in the way of speed, it will be sacrificed in the alter of efficiency. (This is how we end up with the "poor" decisions referenced in the [Explanation (and apology)](#explanation-and-apology))





## **Build**
```bash
git clone https://github.com/Kikols17/Kutils.git
cd Kutils

# Generate the header library at "build/"
make
```

Due to the very weird requirements of this library, (ie. speed), `make` does not produce a shared nor static library, or any kind of binary in fact. Instead, it will produce a series of files like `Kutils.h` or `algorithmsK.h` file, which contains all the functions and macros that this library provides.

This file should be included in your C files, and the functions can be used as if they were part of the standard library. Therefore, the Kutils library is a header-only library, that will be baked into your C files at compile time.

For more information, please consult the [Explanation (and apology)](#explanation-and-apology) section below.

## **Testing**
```bash
cd tests

# Run unit (validity) tests
python3 test.py -v

# Run speed tests
python3 test.py -s

# Run all tests
python3 test.py

# Run both (speed and valid) tests of all tests with prefix "vectorK_"
python3 test.py vectorK_
# Mix and match these flags as you wish
```

Testing is an important part of Kutils development, to make sure that the library behaves in the same way as stdc++, and to ensure that it's performance is better.
To perform these tests we create three files:
- `<name_of_test>.cpp`: A C++ file that performs the test using stdc++.
- `<name_of_test>.c`: A C file that performs the test using Kutils.
- `<name_of_test>.txt`: A File that holds the input values that will be tested. Each line corresponds to a different test case. Usually they all include integer values, that will be used as loop limits or array sizes, as well as random seeds.

It's important to note that `<name_of_test>.cpp` and `<name_of_test>.c` should be mapped one to one (almost) line by line, so that the tests are equivalent, not only in number of operations, but visually. This also helps us to ensure that using Kutils is at least somewhat similar to using stdc++.


## **Explanation (and apology)**
This library was created as an educational project, to learn about data structures and it's optimization, so that I could more deeply understand how stdc++ works under the hood, and to learn how to write faster C.

I wish I was sorry for the decisions made, but they are all for the sake of speed. I'm talking particularly about the egregious use of macros to trick the C preprocessor into basically generating C code dinamically. It's the only way I could find to create a "template" system in C, without having to create a version for every single type, or using "void *" pointers and then using pointers to functions to achieve the same effect. It's not best practice, but if you please consult the [Priorities](#priorities) section, usability is not really a concern :)

The usage of these macros allows us to create functions and structs that derive from a "template", which allows speedup by avoiding to perform casts and checks at runtime (all that is done at compile time, with the code generated by the preprocessor).


